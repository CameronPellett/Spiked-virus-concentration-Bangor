---
title: "draft-2"
author: "Cameron Pellett"
date: "02/12/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.height = 9, fig.width = 9)
```

```{r packages}
library(tidyverse)
library(patchwork)
library(broom)
library(ggbeeswarm)

theme_set(theme_grey()+theme(panel.background = element_rect(fill = "grey96")))
```

```{r functions}

#summarises mean, sd, se, ci for bar charts
mean_ci_summary <- function(data, groups, variable, log10 = FALSE){
  
  data <- data|>ungroup()
  
  for (i in 1:length(groups)) {
    
    data <- data|>
      group_by(.data[[ groups[i] ]], .add = TRUE)
    
  }
  
  if(log10 == TRUE){
    
    data|>
    mutate(varna = case_when(is.na(.data[[variable]]) | is.nan(.data[[variable]]) | is.infinite(.data[[variable]]) ~ as.integer(1),
                             TRUE ~ NA_integer_))|>
      summarise(mean = mean(log10(.data[[variable]]), na.rm = TRUE),
                sd = sd(log10(.data[[variable]]), na.rm = TRUE),
                n = n() - sum(varna, na.rm = TRUE))|>
      mutate(se = sd / sqrt(n),
             ci = se * qt(1 - 0.05 / 2, n-1))
    
  }else {
    
    data|>
      mutate(varna = case_when(is.na(.data[[variable]]) | is.nan(.data[[variable]]) | is.infinite(.data[[variable]]) ~ as.integer(1),
                             TRUE ~ NA_integer_))|>
      summarise(mean = mean(.data[[variable]], na.rm = TRUE),
                sd = sd(.data[[variable]], na.rm = TRUE),
                n = n()  - sum(varna, na.rm = TRUE))|>
      mutate(se = sd / sqrt(n),
             ci = se * qt(1 - 0.05 / 2, n-1))
    
  }
}

pvalue_fun <- function(p.value){
  if(is.na(p.value)){
    NA_character_
  }else if(p.value > 0.05){
    "> 0.05"
  }else if(p.value < 0.05 & p.value > 0.01){
    "< 0.05"
  }else if(p.value < 0.01 & p.value > 0.001){
    "< 0.01"
  }else if(p.value < 0.001){
    "< 0.001"
  }else {
    "something went wrong"
  }
}

pvalue_star <- function(p.value){
  if(is.na(p.value)){
    NA_character_
  }else if(p.value > 0.05){
    "."
  }else if(p.value < 0.05 & p.value > 0.01){
    "*"
  }else if(p.value < 0.01 & p.value > 0.001){
    "**"
  }else if(p.value < 0.001){
    "***"
  }else {
    "something went wrong"
  }
}

stat_paste_fun <- function(stat, log = FALSE){
  if(log != TRUE){
  paste0(str_remove_all(stat[["method"]][[1]], "\n\t"), ": ", 
         str_remove_all(names(stat[["statistic"]]), "Kruskal-Wallis "), " = ",
         round(stat[["statistic"]][[1]],1), ", ",
         if(length(stat[["parameter"]]) == 0)
         {""
         }else if(is.na(stat[["parameter"]])){
           ""
         }else if(length(stat[["parameter"]]) > 0){
           paste0("df = ", round(stat[["parameter"]], 0), ", ")
         } ,
         "p-value ",  pvalue_fun(stat[["p.value"]]))
  }else{
    paste0(str_remove_all(stat[["method"]][[1]], "\n\t"), " (log y): ", 
           str_remove_all(names(stat[["statistic"]]), "Kruskal-Wallis "), " = ",
           round(stat[["statistic"]][[1]],1), ", ",
           if(length(stat[["parameter"]]) == 0)
           {""
           }else if(is.na(stat[["parameter"]])){
             ""
           }else if(length(stat[["parameter"]]) > 0){
             paste0("df = ", round(stat[["parameter"]], 0), ", ")
           } ,
           "p-value ",  pvalue_fun(stat[["p.value"]]))
  }
}

paste_anova_fun <- function(anova, log = FALSE){
  
  if(log != TRUE){
  paste0("ANOVA: ", "F value = ", round((anova$`F value`)[1], 2), ", ", "p-value ", pvalue_fun(anova$`Pr(>F)`[1]))
  }else {
    paste0("ANOVA (log y): ", "F value = ", round((anova$`F value`)[1], 2), ", ", "p-value ", pvalue_fun(anova$`Pr(>F)`[1])) 
  }
}

lmR2adj <- function(lm){
  
  R2 <- 1-((sum(residuals(lm)^2))/
             (sum((lm$model[[1]] - mean(lm$model[[1]]))^2)))
  
  1- ((1 - R2) * (length(lm$model[[1]] ) - 1)/
                 (length(lm$model[[1]] ) - length(lm$coefficients) - 1))
}

lmR2 <- function(lm){
  
  1-((sum(residuals(lm)^2))/
             (sum((lm$model[[1]] - mean(lm$model[[1]]))^2)))
}

glmR2 <- function(glm, adj = FALSE){
  
  residuals <- glm[["y"]] - glm[["fitted.values"]]
  
  R2 <- 1-((sum(residuals^2))/
             (sum((glm$model[[1]] - mean(glm$model[[1]]))^2)))
  
  if(adj != TRUE){
    
  return(R2)
    
  }else {
    
    1- ((1 - R2) * (length(glm$model[[1]] ) - 1)/
                 (length(glm$model[[1]] ) - length(glm$coefficients) - 1))
  }
}



pairwise_diff_comps <- function(pairwise_pv_matrix){
  
  pairwise_diff <- as_tibble(pairwise_pv_matrix, rownames = "vars")|>
  pivot_longer(2:last_col(), names_to = "var.y", values_to = "p.value")|>
  na.omit()|>
  filter(p.value < 0.05)|>
  select(1,2)|>
  unite("comp", c(1,2), sep = " ~ ")
  
  comp_diffs <- ""
  
  for (i in 1:nrow(pairwise_diff)) {
    
    if(i == nrow(pairwise_diff)){
      comp_diffs <- paste0(c(comp_diffs, pairwise_diff[[i,1]]), collapse = ", and ")
    }else if(i != 1){
      comp_diffs <- paste0(c(comp_diffs, pairwise_diff[[i,1]]), collapse = ", ")
    }else{
      comp_diffs <- pairwise_diff[[i,1]]
    }
    
  }
  
  return(comp_diffs)
}

plot_assumptions <- function(model, obs, bins = 30){
        #create tibble for use in ggplot of model assumptions
        df <- tibble(
                observations = obs,
                fitted = fitted(model),
                residuals = resid(model),
                standardised_residuals = sqrt(resid(model)^2),
                RMSresiduals = sqrt(mean(resid(model)^2)))
        
        
        a <- ggplot(df, aes(fitted, residuals))+
                geom_point()+
                geom_abline(aes(slope = 0, intercept = 0))
                #labs(title = "Heteroscedasticity", subtitle = "Check trends not captured by model")
        
        b <- ggplot(df, aes(residuals))+
                geom_histogram(bins = bins)
        
        c <- ggplot(df, aes(sample = residuals))+
                geom_qq()+
                geom_qq_line()#+
                #labs(title = "Quantile-quantile plot", subtitle = "check normality of residuals")
        
        d <- ggplot(df, aes(observations, fitted))+
                geom_point()+
                geom_abline()#+
                #labs(subtitle = "Check accuracy of model across whole dataset")
        
        plot <- a+b+c+d+plot_layout(ncol = 2, nrow = 2)+plot_annotation(tag_levels = "a")
        return(plot)
} 

```


```{r data import and clean}

data <- read_csv("Spiking_data.csv")

virus_char <- read_csv("virus_characteristics.csv")|>
  pivot_longer(2:12, names_to = "virus", values_to = "value")|>
  pivot_wider(names_from = "X1", values_from = "value")|>
  mutate(virus = str_replace_all(virus, c("SARS" = "N1")))

clean <- data|>
  select(-Sample_code)|>
  rename("method" = Method, "spike" = Spike,
         "water_type" = Water_type,
         "volume" = Volume, "replicate" = Replicate)|>
  pivot_longer(cols = contains("rec"), names_to = "virus", values_to = "rec")|>
  mutate(virus = str_remove_all(virus, "_Rec%| Rec%"))|>
  mutate(rec = case_when((spike == "U" & virus %in% c("N1", "Phi6", "NoVGII") )~ NA_real_,
                         spike == "S" & water_type == "DW" & virus %in% c("AdV", "PMMoV", "CrAss") ~ NA_real_,
                         TRUE ~ rec))|>
  filter(!method %in% c("Pellet", "Pellet_BE"))|>
  left_join(virus_char, by = "virus")|>
  mutate(rec = case_when(round(rec,2) <= 0 ~ NA_real_,
                         TRUE ~ round(rec,2)),
         shape = factor(shape),
         water_type = factor(water_type),
         enveloped = factor(enveloped),
         size_nm = as.double(size_nm),
         method = factor(method),
         genome = factor(genome),
         samples_spiked = str_replace_all(samples_spiked, c("yes" = "S",
                                                            "no" = "U")))|>
  na.omit()


pellet <- data|>
  select(-Sample_code)|>
  rename("method" = Method, "spike" = Spike,
         "water_type" = Water_type,
         "volume" = Volume, "replicate" = Replicate)|>
  pivot_longer(cols = contains("rec"), names_to = "virus", values_to = "rec")|>
  mutate(virus = str_remove_all(virus, "_Rec%| Rec%"))|>
  mutate(rec = case_when((spike == "U" & virus %in% c("N1", "Phi6", "NoVGII") )~ NA_real_,
                         spike == "S" & water_type == "DW" & virus %in% c("AdV", "PMMoV", "CrAss") ~ NA_real_,
                         TRUE ~ rec))|>
  filter(method %in% c("Pellet", "Pellet_BE", "PEG", "BE-PEG"))|>
  left_join(virus_char, by = "virus")|>
  mutate(rec = case_when(round(rec,2) <= 0 ~ NA_real_,
                         TRUE ~ round(rec,2)),
         shape = factor(shape),
         water_type = factor(water_type),
         enveloped = factor(enveloped),
         size_nm = as.double(size_nm),
         method = factor(method))|>
  na.omit()|>
  mutate(BE = case_when(str_detect(method, "BE") ~ "Beef extract",
                        TRUE ~ "No beef extract"))

```


```{r notes}

notes <- (tibble(estimate.x = "p-value: < 0.001 [***]; < 0.01 [**]; < 0.05 [*]; > 0.05 [.]"))
```


```{r full dataset plot, fig.height = 13, fig.width=9}
ww_all <- clean|>
  filter(water_type == "WW")|>
  mutate(volume = fct_reorder(.f = factor(paste0(volume, "ml WW")), .x = volume, .fun = median),
         shape1 = case_when(method == "Amicon" & volume == "20ml" ~ as.integer(32),
                            virus %in% c("AdV", "PMMoV", "CrAss") ~ as.integer(32),
                            TRUE ~ as.integer(16)),
         shape2 = case_when(method == "Amicon" & volume == "20ml" ~ as.integer(16),
                            TRUE ~ as.integer(32)),
         shape3 = case_when(virus %in% c("AdV", "PMMoV", "CrAss") & volume != "20ml" ~ as.integer(16),
                            TRUE ~ as.integer(32)))|>
  ggplot(aes(y = rec, x =method))+
  geom_beeswarm(aes(shape = shape1), priority = "ascending", cex = 4, show.legend = F)+
  geom_beeswarm(aes(shape = shape2), priority = "ascending", cex = 12, show.legend = F)+
  geom_beeswarm(aes(shape = shape3), priority = "ascending", cex = 6, show.legend = F)+
  geom_beeswarm(aes(shape = shape1), priority = "ascending", cex = 4, show.legend = F, size = 0.1, colour = "white")+
  geom_beeswarm(aes(shape = shape2), priority = "ascending", cex = 12, show.legend = F, size = 0.1, colour = "white")+
  geom_beeswarm(aes(shape = shape3), priority = "ascending", cex = 6, show.legend = F, size = 0.1, colour = "white")+
  scale_shape_identity()+
  scale_y_continuous(sec.axis = sec_axis( trans=~.*1, name="Virus", labels = NULL, breaks = NULL))+
  facet_grid(samples_spiked + virus~ volume, scale = "free", space = "free_x")+
  labs(x = "Concentration method", y = "Recovery (%)")

dw_all <- clean|>
  filter(water_type == "DW")|>
  mutate(volume = fct_reorder(.f = factor(paste0(volume, "ml DW")), .x = volume, .fun = median),
         shape1 = case_when(method == "Amicon" & volume == "20ml" ~ as.integer(32),
                            virus %in% c("AdV", "PMMoV", "CrAss") ~ as.integer(32),
                            TRUE ~ as.integer(16)),
         shape2 = case_when(method == "Amicon" & volume == "20ml" ~ as.integer(16),
                            TRUE ~ as.integer(32)),
         shape3 = case_when(virus %in% c("AdV", "PMMoV", "CrAss") & volume != "20ml" ~ as.integer(16),
                            TRUE ~ as.integer(32)))|>
  ggplot(aes(y = rec, x =method))+
  geom_beeswarm(aes(shape = shape1), priority = "ascending", cex = 4, show.legend = F)+
  geom_beeswarm(aes(shape = shape2), priority = "ascending", cex = 12, show.legend = F)+
  geom_beeswarm(aes(shape = shape3), priority = "ascending", cex = 6, show.legend = F)+
  geom_beeswarm(aes(shape = shape1), priority = "ascending", cex = 4, show.legend = F, size = 0.1, colour = "white")+
  geom_beeswarm(aes(shape = shape2), priority = "ascending", cex = 12, show.legend = F, size = 0.1, colour = "white")+
  geom_beeswarm(aes(shape = shape3), priority = "ascending", cex = 6, show.legend = F, size = 0.1, colour = "white")+
  scale_shape_identity()+
  scale_y_continuous(sec.axis = sec_axis( trans=~.*1, name="Virus", labels = NULL, breaks = NULL))+
  facet_grid(samples_spiked + virus~ volume, scale = "free", space = "free_x")+
  labs(x = "Concentration method", y = "Recovery (%)")

WWDW_all <- (ww_all + theme(axis.title.x = element_blank())) / dw_all + plot_layout(heights = c(1.1, 0.8))
```

## 2. Methods

### 2.1 Statistical methodology 

Data analysis and statistical tests were carried out in R (R Core Team, 2020); the full script and data are provided in a dedicated repository (https://github.com/CameronPellett/Spiked-virus-concentration-Bangor).

Sample starting volume, concentration method, water type, target virus shape, target virus genome type, and virus envelope were selected as factors and co-variates of viral recovery. The selected features were assessed in combination as predictors of viral recovery using a generalised linear model (glm) with the response variable modelled as a Gamma distribution with a logistic link function (Eq. 1; see supplementary materials Figure S2 for residuals plots).

 $$  
Recovery_{i} = exp[\beta_{0} + \beta_{1} \space Method_{i} + \beta_{2} \space Water \space Type_{i} + \beta_{3} \space Shape_{i} + \beta_{4} \space Envelope_{i} + \beta_{5} \space Genome_{i} + \epsilon] \quad \quad (Eq.1) $$ 



Following the glm, comparisons of individual features were visualized and statistical tests were carried out. For statistical tests the recovery percentile was log transformed to meet assumptions of a Gaussian distribution. Statistical comparisons of features with two levels were made with Welch two sample t-tests and comparisons with three or more levels were made with a one-way ANOVA, followed by pairwise Welch two sample t-tests. Paired tests were not selected due to missing data created by removal of undetermined results and removal during qPCR quality control.

<br>

## 3. Results

The generalised linear model identified sample starting volume, concentration method, water type, target virus shape, and virus genome type as significant predictors of viral recovery (Table 1). The viral envelope did not have a p-value less than 0.05; however with a p-value < 0.06 further analysis was carried out.


<br>

Table1: generalised linear model with Gamma residuals (link = log) predicting recovery of spiked virus. Pellet methods were excluded from the model due to non-standard starting volumes. The model results include the variable coefficient on a log scale indicating its effect (positive numbers indicating increased recovery), followed by the standard error in brackets, and a significance code (`r notes`). The Amicon method, de-ionised water (DW), head-tail viruses, and DNA viruses are included in the baseline intercept.


```{r overview multiple linear model}
glm <- glm(rec ~ volume + method + water_type + shape + enveloped + genome, data = clean, family = Gamma(link = "log"))

lm_table <- tidy(glm)|>
  mutate(term = str_replace_all(term, c("[(]Intercept[)]" = "Intercept",
                                        "volume" = "Volume",
                                        "methodAS" = "Method: AS",
                                        "methodBE-PEG" = "Method: BE-PEG",
                                        "methodIP" = "Method: IP",
                                        "methodPEG" = "Method: PEG",
                                        "size_nm" = "Virus genome size (nm)",
                                        "water_typeWW" = "Water type: WW",
                                        "shapespherical" = "Virus shape: spherical",
                                        "shapehelical" = "Virus shape: helical",
                                        "shapeicosahedral" = "Virus shape: icosahedral",
                                        "envelopedyes" = "Enveloped: TRUE",
                                        "genomeRNA" = "Virus genome: RNA")),
         across(2:4, ~round(.x, 3)))|>
  rowwise()|>
  mutate(p.value = pvalue_star(p.value))|>
  unite(col = "estimate", c("estimate", "std.error"), sep = " (")|>
  unite(col = "estimate", c(2,4), sep = ") ")|>
  select(-statistic)


aicr2 <- tibble(
  term = c("AIC", "R-squared", "Adj. R-squared"), 
  estimate = c(AIC(glm), glmR2(glm), glmR2(glm, adj = TRUE))
)|>
  mutate(across(2, ~as.character(round(.x, 3))))



lm_table_fin <- lm_table|>
  bind_rows(tibble(term = ""))|>
  bind_rows(aicr2)|>
  mutate(across(1:2, ~replace_na(.x, "")))

knitr::kable(lm_table_fin, col.names = c("Variables", "Coefficients"))

```


<br>


### 3.1. Greater recovery of spiked virus in de-ionised water compared to watewater


```{r water type comp}
wt_comp <- clean|>
  filter(spike == "S" & samples_spiked == "S")

wt_comp_t.t <- tibble(label = stat_paste_fun(t.test(log(rec) ~ water_type, data = wt_comp), log = TRUE),
       row = 1)

(wt_comp|>
  mutate(row = row_number())|>
  left_join(wt_comp_t.t, by = "row")|>
  ggplot(aes(water_type, rec))+
  geom_boxplot(width = 2, outlier.alpha = 0)+
  geom_beeswarm(alpha = 0.5)+
    geom_beeswarm(shape = ".", colour = "white")+
  geom_text(aes(x = 1.5, y = max(rec) + (0.07 * (max(rec) - min(rec))),
                label = label), size = 3)+
  labs(x = "Water type",
       y = "Recovery (%)")) +
  
  (wt_comp|>
  ggplot(aes(water_type, rec))+
  geom_boxplot(width = 2, outlier.alpha = 0)+
  geom_beeswarm(alpha = 0.3, cex = 3, size = 1)+
    geom_beeswarm(cex = 3, shape = ".", colour = "white")+
  facet_wrap(~virus, scale = "free", ncol = 4)+
  labs(x = "Water type",
       y = "Recovery (%)") +
  theme(axis.title.y = element_blank())) +
  
  plot_layout(widths = c(1.3, 0.7), nrow = 2, ncol = 1) +
    plot_annotation(tag_levels = "a")
  
```


Figure 1: Greater recovery of spiked virus in de-ionised water compared to watewater. Panel 'a' combines all spiked virus recovery results and panel 'b' separates recovery by virus with a variable y scale. Comparisons were made with a Welch Two Sample t-test after log transformation of recovery. 


<br>


### 3.2. Viral recovery improved with reduced starting volume of wastewater


```{r volume}

clean_ww <- clean|>
  filter(water_type == "WW")

vol_ww <- clean_ww|>
  filter(!method %in% c("Amicon", "IP"))

glm_ww <- glm(rec ~ volume, data = vol_ww, family = Gamma(link = "log"))
lm_ww <- lm(log(rec) ~ as.factor(volume), data = vol_ww)

vol_comp_aov <- tibble(label = paste_anova_fun(anova = anova(lm_ww), log = TRUE),
                       row = 1)

pairwise.vol.ttest <- pairwise.t.test(log(vol_ww$rec), as.factor(vol_ww$volume))[["p.value"]]|>
  as_tibble(rownames = "volx")|>
  pivot_longer(2:3, names_to = "voly", values_to = "p.v")

vol_ww|>
  mutate(volume = fct_reorder(factor(volume), volume),
         row = row_number())|>
  left_join(vol_comp_aov, by = "row")|>
  ggplot(aes(volume, rec))+
  geom_boxplot(outlier.alpha = 0)+
  geom_beeswarm(alpha = 0.5)+
  geom_beeswarm(shape = ".", colour = "white")+
  geom_text(aes(x = 2, y = max(rec) + (0.07 * (max(rec) - min(rec))),
                label = label), size = 3)+
  labs(x = "Volume (ml)",
       y = "Recovery (%)") +
  
  vol_ww|>
  mutate(volume = fct_reorder(factor(volume), volume))|>
  ggplot(aes(volume, rec))+
  geom_boxplot(outlier.alpha = 0)+
  geom_beeswarm(alpha = 0.3, cex = 3, size = 1)+
  geom_beeswarm(shape = ".", cex = 3, colour = "white")+
  facet_wrap(~virus, scales = "free")+
  labs(x = "Volume (ml)",
       y = "Recovery (%)")+
  theme(axis.title = element_blank(),
        axis.text.x = element_text(angle = 90)) +
  
  plot_layout(widths = c(1.3, 0.7), nrow = 2, ncol = 1) + plot_annotation(tag_levels = "a")

```


Figure 2: Viral recovery improved with reduced starting volume of wastewater. Panel 'a' combines all recovery results and panel 'b' separates recovery by virus with a variable y scale. Comparisons were made with an ANOVA after log transformation of recovery, followed by pairwise t tests; Pairwise comparisons found significant differences between all volumes with the holm adjustment method (p-value < 0.05: `r filter(pairwise.vol.ttest, p.v < 0.05)|>unite(vol_comp, c(volx, voly), sep = " ~ ")|>pull(vol_comp)|>paste0(collapse = "; ")`).


<br>


### 3.3. BE-PEG and Amicon concentration methods have the greatest viral recovery 


```{r, method}

clean_ww_15 <- clean_ww|>
  filter(volume == 15)

lm_meth <- lm(log(rec) ~ method, data = clean_ww_15)
meth_comp_aov <- tibble(label = paste_anova_fun(anova = anova(lm_meth), log = TRUE),
                       row = 1)


clean_ww_15|>
  mutate(method = fct_reorder(method, rec),
         row = row_number())|>
  left_join(meth_comp_aov, by = "row")|>
  ggplot(aes(method, rec))+
  geom_boxplot(outlier.alpha = 0)+
  geom_beeswarm(alpha = 0.5)+
  geom_beeswarm(shape = ".", colour = "white")+
  geom_text(aes(x = 3, y = max(rec) + (0.07 * (max(rec) - min(rec))),
                label = label), size = 3)+
  labs(x = "Concentration method",
       y = "Recovery (%)") +
  
  clean_ww_15|>
  mutate(method = fct_reorder(str_replace_all(method, "Amicon", "Ami"), rec))|>
  ggplot(aes(method, rec))+
  geom_boxplot(outlier.alpha = 0)+
  geom_beeswarm(alpha = 0.3, cex = 3, size = 1)+
  geom_beeswarm(shape = ".", cex = 3, colour = "white")+
  facet_wrap(~virus, scale = "free")+
  labs(x = "Concentration method",
       y = "Recovery (%)") +
  
  plot_layout(heights = c(1.3, 0.7), nrow = 2, ncol = 1) + plot_annotation(tag_levels = "a")
  
```


Figure 3: Concentration methods influence virus recovery at a starting volume of 15ml. Panel 'a' combines all recovery results with starting volumes of 15ml and panel 'b' separates recovery by virus with a variable y scale. Comparisons were made with an ANOVA after log transformation of recovery, followed by pairwise t tests; BE-PEG and Amicon methods had the highest median recovery, but due to Amicon's greater variance, pairwise comparisons with IP (third highest median recovery) were only significantly different for  BE-PEG (p-value < 0.05).


<br>


### 3.4. Removal of the sample solid fraction via centrifugation is likely to increase viral recovery


```{r pellet}
facets <- pellet|>ungroup()|>count(BE)|>pull(BE)
t.test.pellet <- tibble(BE = facets, label = NA_character_, row = 2)
for (i in 1:length(facets)) {
  
  t.test.pellet[i,2] <- stat_paste_fun(t.test(log10(rec) ~ method, data = (pellet|>filter(BE == facets[i])) ), log = TRUE)
  
}



pellet|>
  group_by(BE)|>
  mutate(row = row_number(),
         max = max(rec),
         min = min(rec),
         method = str_replace_all(method, "Pellet_BE", "BE-Pellet"))|>
  left_join(t.test.pellet, by = c("BE", "row"))|>
  ggplot(aes(method, rec))+
  geom_boxplot(outlier.alpha = 0)+
  geom_beeswarm(alpha = 0.5)+
  geom_beeswarm(shape = ".", colour = "white")+
  geom_text(aes(x = 1.5, y = max + (0.07 * (max - min)),
                label = label), size = 3)+
  facet_wrap(~BE, scales = "free")+
  labs(x = "Concentration method",
       y = "Recovery (%)") +
  theme(axis.title.x = element_blank())+ 
  
  pellet|>
  mutate(method = str_remove_all(method, "BE-|_BE"))|>
  ggplot(aes(method, rec))+
  geom_boxplot(outlier.alpha = 0)+
  geom_beeswarm(alpha = 0.3, cex = 3, size = 1)+
  geom_beeswarm(shape = ".", cex = 3, colour = "white")+
  facet_grid(BE~virus, scales = "free")+
  labs(x = "Concentration method",
       y = "Recovery (%)")+
  theme(axis.text.x = element_text(angle = 90)) +
  
  plot_layout(nrow = 2, heights = c(1.3,0.7)) + plot_annotation(tag_level = "a")


```


Figure 4: The sample solid fraction (Pellet) has significantly lower viral recovery than the concentrated sample; thus removal via centrifugation will likely increase the median viral recovery of a concentrated sample. Panel 'a' combines all recovery results with starting volumes of 50ml and panel 'b' separates recovery by virus with a variable y scale. Comparisons were made with a Welch Two Sample t-test after log transformation of recovery. 


<br>


### 3.5. Virus shape, genome and envelope influence viral recovery


```{r virus characteristics}
shape.anova <- tibble(label = paste_anova_fun(anova(lm(log(rec) ~ shape, clean_ww)), log = TRUE),
                      row = 1)

shape <- clean_ww|>
  mutate(row = row_number(),
         shape = fct_reorder(shape, rec))|>
  left_join(shape.anova, by = "row")|>
  ggplot(aes(shape, rec))+
  geom_boxplot(outlier.alpha = 0)+
  geom_beeswarm(alpha = 0.5)+
  geom_beeswarm(shape = ".", colour = "white")+
  geom_text(aes(x = 2.5, y = max(rec) + (0.07 * (max(rec) - min(rec))),
                label = label), size = 3)+
  labs(x = "Virus shape",
       y = "Recovery (%)")

enveloped.t.test <- tibble(label = stat_paste_fun(t.test(log(rec) ~ enveloped, clean_ww), log = TRUE),
                           row = 1)

enveloped <- clean_ww|>
  mutate(row = row_number())|>
  left_join(enveloped.t.test, by = "row")|>
  ggplot(aes(enveloped, rec))+
  geom_boxplot(outlier.alpha = 0)+
  geom_beeswarm(alpha = 0.5)+
  geom_beeswarm(shape = ".", colour = "white")+
  geom_text(aes(x = 1.5, y = max(rec) + (0.07 * (max(rec) - min(rec))),
                label = label), size = 3)+
  labs(x = "Virus enveloped",
       y = "Recovery (%)")

genome.t.test <- tibble(label = stat_paste_fun(t.test(log(rec) ~ genome, clean_ww), log = TRUE),
                        row = 1)

genome <- clean_ww|>
  mutate(row = row_number())|>
  left_join(genome.t.test, by = "row")|>
  ggplot(aes(genome, rec))+
  geom_boxplot(outlier.alpha = 0)+
  geom_beeswarm(alpha = 0.5)+
  geom_beeswarm(shape = ".", colour = "white")+
  geom_text(aes(x = 1.5, y = max(rec) + (0.07 * (max(rec) - min(rec))),
                label = label), size = 3)+
  labs(x = "Viral genome",
       y = "Recovery (%)")

(enveloped + genome) / shape + plot_annotation(tag_levels = "a")
```


Figure 5: Virus characteristics influence viral recovery. Panel 'a' compares viruses with and without an envelope, panel 'b' compares RNA and DNA viruses, and panel 'c' compares viruses of different shapes. Statistical comparisons were carried out after log transformation of recovery: comparisons with three or more levels were done with an ANOVA, and comparisons with two levels were done with a Welch Two Sample t-test.


<br>


## 5. Supplimentary materials 


```{r plot S1 dwww_all}
WWDW_all
```


Figure S1: recovery percentage for all 11 spiked (S) and unspiked (U) viruses grouped by wastewater (WW), de-ionised water (DW), sample volume (ml), and concentration method. Points have been offset on the horizontal axis to avoid over plotting.
